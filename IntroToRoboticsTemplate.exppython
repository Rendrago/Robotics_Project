{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ndriveMotors_motor_a = Motor(Ports.PORT9, True)\ndriveMotors_motor_b = Motor(Ports.PORT10, False)\ndriveMotors = MotorGroup(driveMotors_motor_a, driveMotors_motor_b)\nlightSensor = Light(brain.three_wire_port.a)\ndistanceSensor = Distance(Ports.PORT1)\nrightLineTracker = Line(brain.three_wire_port.b)\nmiddleLineTracker = Line(brain.three_wire_port.c)\nleftLineTracker = Line(brain.three_wire_port.d)\nmotor_2 = Motor(Ports.PORT2, False)\n# AI Vision Color Descriptions\nvisionSensor__RedRing = Colordesc(1, 221, 20, 72, 10, 0.2)\nvisionSensor__BlueRing = Colordesc(2, 6, 27, 126, 10, 0.2)\n# AI Vision Code Descriptions\nvisionSensor = AiVision(Ports.PORT3, visionSensor__RedRing, visionSensor__BlueRing)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:     Intro to Robotics\n#\tAuthor:       \n#\tCreated:\n#\tDescription:  Intro to Robotics Class File\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n#Function Section\n'''\nDescription: Moves the robot linearly for a given distance\nArg:\n- distance (float): distance in inches\nReturns:\n- None\n''' \n#def linear_movement(distance):\ndef linear_movement(distance):\n    #change motor speed\n    driveMotors.set_velocity(200,RPM)\n\n    #calculate number of rotations\n    circumfrence = 3.25 * 3.14\n    rotations = distance / circumfrence\n\n    #spins motor set number of rotations then stops\n    driveMotors.spin_for(FORWARD,rotations,TURNS)\n    driveMotors.stop()\n\n'''\nDescription: Turns robot a set number of degrees manually\nArg:\n- degrees (float): a number in degrees\nReturns:\n- None\n''' \n\ndef linear_inertial(velocityOfVehicle, distanceFromObject):\n    kp = 0.8\n    brain_inertial.set_rotation(0,DEGREES)\n    driveMotors.set_velocity(velocityOfVehicle,RPM)\n    driveMotors.spin(FORWARD)\n    #conditional control group\n    while True:\n        #if an object is at a set distance\n        if distanceReading <= distanceFromObject:\n            break\n        else:\n            #calculate the error from facing straight\n            error = 0 - brain_inertial.rotation(DEGREES)\n            speed = error * kp\n\n            driveMotors_motor_a.set_velocity(velocityOfVehicle + speed, PERCENT)\n            driveMotors_motor_b.set_velocity(velocityOfVehicle - speed, PERCENT)\n\n            driveMotors_motor_a.spin(FORWARD)\n            driveMotors_motor_a.spin(FORWARD)\n    driveMotors.stop()\n\n\ndef robot_turn(degrees):\n    #change motor speed\n    driveMotors.set_velocity(25,PERCENT)\n\n    #calculate wheel circumference\n    wheelCircumference = 3.25 * 3.14\n\n    #calculate robot circumference\n    robotCircumference = 3.14 * 7.75\n\n    #calculate arc length\n    arcLength = (degrees/360)* robotCircumference\n\n    #calculate rotations\n    rotations = arcLength / wheelCircumference\n\n    #spins motor set number of rotations then stops\n    driveMotors_motor_a.spin_for(FORWARD,rotations,TURNS,wait=False)\n    driveMotors_motor_b.spin_for(REVERSE, rotations, TURNS)\n    driveMotors.stop()\n\n    driveMotors_motor_a.spin_for(FORWARD,2) \n    #activates just motor A\n    driveMotors_motor_b.spin_for(FORWARD,2) \n    #activates just motor B\n\n\n\n'''\nDescription: Turns robot using the inertial sensor data\n# of Sensors: 1\nArg:\n- degrees (float): a number in degrees\nReturns:\n- None\n''' \ndef inertial_turn(degrees):\n    #proportional percentage\n    kp = 0.8\n    #reset rotation value\n    brain_inertial.set_rotation(0,DEGREES)\n\n    while True:\n        #calculate error in relation to closeness of desired degree\n        gError = degrees - brain_inertial.rotation(DEGREES)\n\n        #we will stop within 1.5 degrees from the target\n        if ( abs(gError) <1.5):\n            break\n\n        #adjust speed based on error and proportional\n        speed = gError * kp\n        driveMotors.set_velocity(-speed,PERCENT)\n        driveMotors_motor_a.spin(REVERSE)\n        driveMotors_motor_b.spin(FORWARD)\n\n    #stop turn\n    driveMotors.stop()    \n\ndef inertial_line_follower(motorSpeed,Kp):\n    threshold = (ltRightReading + ltMiddleReading + ltLeftReading)/3\n    driveMotors.set_velocity(motorSpeed,PERCENT)\n    driveMotors.spin(FORWARD)\n    '''while True:\n        leftError = ltRightReading - threshold\n        rightError = ltLeftReading - threshold\n        driveMotors.set_velocity(motorSpeed,PERCENT)\n        driveMotors.spin(FORWARD)\n        if ltLeftReading <= threshold:\n            driveMotors_motor_a.set_velocity(Kp*rightError,PERCENT)\n            driveMotors_motor_a.spin(REVERSE)\n        elif ltRightReading <= threshold:\n            driveMotors_motor_b.set_velocity(Kp*leftError,PERCENT)\n            driveMotors_motor_b.spin(REVERSE)'''\n    while True:\n        rightError = threshold - ltRightReading\n        leftError = threshold - ltLeftReading\n        if ltLeftReading <= threshold:\n            driveMotors_motor_b.set_velocity(((Kp*leftError)*motorSpeed)+motorSpeed,PERCENT)\n            driveMotors_motor_a.set_velocity(((Kp*rightError)*motorSpeed)+motorSpeed,PERCENT)\n        wait(.1,SECONDS)\n\n'''\nDescription: Collects the current brightness level\n# of Sensor: 1 (update to correct value)\nArg:\n- None\nReturns:\n- None\n'''\ndef light_readings():\n    while True:\n        global lightReading\n        lightReading = lightSensor.brightness(PERCENT)\n        wait(0.02,SECONDS)\n\n'''\nDescription: Collects the current distance, object in view velocity, and object in view size\n# of Sensor: 1 (update to correct value)\nArg:\n- None\nReturns:\n- None\n'''\ndef distance_readings():\n    global distanceReading\n    global objectVelocity\n    global objectSize\n    while True:\n        distanceReading = distanceSensor.object_distance(INCHES)\n        objectVelocity = distanceSensor.object_velocity()\n        objectSize = distanceSensor.object_size()\n        wait(.02,SECONDS)\n'''\nDescription: Collects the current color value and if an April Tag is available\n# of Sensor: 1 (update to correct value)\nArg:\n- None\nReturns:\n- None\n'''\ndef vision_readings():\n    global BlueRingWidth\n    global BlueRingHeight\n    global BlueRingCenterX\n    global BlueRingCenterY\n    global BlueRingNumObjects\n    global RedRingWidth\n    global RedRingHeight\n    global RedRingCenterX\n    global RedRingCenterY\n    global RedRingNumObjects\n    BlueRingWidth = None\n    BlueRingHeight = None\n    BlueRingCenterX = None\n    BlueRingCenterY = None\n    BlueRingNumObjects = None\n    RedRingWidth = None\n    RedRingHeight = None\n    RedRingCenterX = None\n    RedRingCenterY = None\n    RedRingNumObjects = None\n    while True:\n        wait(.02,SECONDS)\n        BlueRingObjects = visionSensor.take_snapshot(visionSensor__BlueRing)\n        RedRingObjects = visionSensor.take_snapshot(visionSensor__RedRing)\n        if BlueRingObjects[0].exists:\n            BlueRingNumObjects = len(BlueRingObjects)\n            BlueRingWidth = BlueRingObjects[0].width\n            BlueRingHeight = BlueRingObjects[0].height\n            BlueRingCenterX = BlueRingObjects[0].centerX\n            BlueRingCenterY = BlueRingObjects[0].centerY\n        else:\n            BlueRingWidth = None\n            BlueRingHeight = None\n            BlueRingCenterX = None\n            BlueRingCenterY = None\n            BlueRingNumObjects = None\n        if RedRingObjects[0].exists:\n            RedRingNumObjects = len(RedRingObjects)\n            RedRingWidth = RedRingObjects[0].width\n            RedRingHeight = RedRingObjects[0].height\n            RedRingCenterX = RedRingObjects[0].centerX\n            RedRingCenterY = RedRingObjects[0].centerY\n        else:\n            RedRingWidth = None\n            RedRingHeight = None\n            RedRingCenterX = None\n            RedRingCenterY = None\n            RedRingNumObjects = None\n'''\nDescription: Collects the current reflection value\n# of Sensor: 1 (update to correct value)\nArg:\n- None\nReturns:\n- None\n'''\ndef linetracker_readings():\n    while True:\n        global ltRightReading\n        global ltMiddleReading\n        global ltLeftReading\n        ltRightReading = rightLineTracker.reflectivity(PERCENT)\n        ltMiddleReading = middleLineTracker.reflectivity(PERCENT)\n        ltLeftReading = leftLineTracker.reflectivity(PERCENT)\n\n        wait(.2,SECONDS)\n\n'''\nDescription: Opens/Closes the claw a set number of degrees\n# of Sensor: 1\nArg:\n- degrees (float): a number in degrees\nReturns:\n- None\n'''\n#def move_claw(degrees):\n\n\n'''\nDescription: Moves the claw arm a set number of degrees up/down\n# of Sensor: 1 (update to current value)\nArg:\n- degrees (float): a number in degrees\nReturns:\n- None\n'''\n#def move_arm(degrees):\n\n\n'''\nDescription: Collects the current degree value\n# of Sensor: 1 (update to correct value)\nArg:\n- None\nReturns:\n- None\n'''\n#def potentiometer_readings():\n\n\n'''\nDescription: Collects the current hue reading. \n# of Sensors: 1 (update to correct value)\nArg:\n- None\nReturns: \n- None\n'''\n#def optical_readings():\n\n\n'''\nDescription: Prints the values from desired sensors onto the EXP Brain Screen\nArg:\n- None\nReturns:\n- None\n'''\ndef display_data():\n    brain.screen.set_font(FontType.PROP20)\n    wait(0.05,SECONDS)\n    while True:\n        brain.screen.print(\"Num. Objects: \",BlueRingNumObjects)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 1 Width: \",BlueRingWidth)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 1 Height: \",BlueRingHeight)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 1 CenterX: \",BlueRingCenterX)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 1 CenterY: \",BlueRingCenterY)\n        brain.screen.print(\"Num. Objects: \",RedRingNumObjects)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 2 Width: \",RedRingWidth)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 2 Height: \",RedRingHeight)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 2 CenterX: \",RedRingCenterX)\n        brain.screen.next_row()\n        brain.screen.print(\"Object 2 CenterY: \",RedRingCenterY)\n        '''brain.screen.print(\"Position:\",driveMotors.position(DEGREES))\n        brain.screen.next_row()\n        brain.screen.print(\"Light:\",lightReading)\n        brain.screen.next_row()\n        brain.screen.print(\"Distance:\",distanceReading, \"m\")\n        brain.screen.next_row()\n        brain.screen.print(\"Velocity:\",objectVelocity, \"m/s\")\n        brain.screen.next_row()\n        brain.screen.print(\"Object Size:\",objectSize)\n        wait(.75,SECONDS)\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1,1)'''\n\n#Thread Section \n#lightSensorThread = Thread(light_readings)\n#lineTrackerThread = Thread(linetracker_readings)\nvisionSensorReadings = Thread(vision_readings)\n#distanceSensorThread = Thread(distance_readings)\ndisplayDataThread = Thread(display_data)\n#SD Card File Setup for Writing Data\n\n#Inertial Sensor Setup\nbrain_inertial.calibrate()\nwhile brain_inertial.is_calibrating():\n    wait(50,MSEC)\n#Sub-Tasks (custom functions that handle scenarios. Ex: go_up_ramp())\nwhile not brain.sdcard.is_inserted():\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(\"Sd Card Missing\")\n    wait(5,MSEC)\n    brain.screen.clear_screen()\n\n#file = open(\"myRobot.csv\",\"w\")\n#file.write(\"{},{}\\n\".format(\"Position\",\"Light\"))\n#Main Program\nx = 200 * .15\nwhile True:\n   while distanceReading > 8:\n       driveMotors_motor_a.spin(FORWARD)\n       driveMotors_motor_a.spin(REVERSE)\n   linear_inertial(x,8)\n   if distanceSensor.object_velocity() < 0:\n       x += (200 * .10)","textLanguage":"python","robotConfig":[{"port":[9,10],"name":"driveMotors","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[1],"name":"lightSensor","customName":true,"deviceType":"Light","deviceClass":"light","setting":{},"triportSourcePort":22},{"port":[1],"name":"distanceSensor","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[2],"name":"rightLineTracker","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[3],"name":"middleLineTracker","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[4],"name":"leftLineTracker","customName":true,"deviceType":"LineTracker","deviceClass":"line","setting":{},"triportSourcePort":22},{"port":[2],"name":"motor_2","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"visionSensor","customName":true,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[{\"id\":1,\"name\":\"RedRing\",\"nameValid\":\"Valid\",\"lastValidName\":\"RedRing\",\"red\":221.22908512720156,\"green\":19.9045988258317,\"blue\":72.34546232876713,\"hueRange\":10,\"saturationRange\":0.2},{\"id\":2,\"name\":\"BlueRing\",\"nameValid\":\"Valid\",\"lastValidName\":\"BlueRing\",\"red\":5.684217955957086,\"green\":27.44148785996612,\"blue\":126.10206098249577,\"hueRange\":10,\"saturationRange\":0.2}],\"codes\":[],\"tags\":false,\"AIObjects\":false,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"]}","isConfigured":"false"},"triportSourcePort":22}],"slot":0,"platform":"EXP","sdkVersion":"20240611.19.00.00","appVersion":"4.0.0","minVersion":"4.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"target":"Physical"}